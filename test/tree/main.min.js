/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* global Angel  */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Calcu = __webpack_require__(1);

	var _Calcu2 = _interopRequireDefault(_Calcu);

	var _Canvas = __webpack_require__(2);

	var _Canvas2 = _interopRequireDefault(_Canvas);

	var _Store = __webpack_require__(3);

	var _Store2 = _interopRequireDefault(_Store);

	var _CONST = __webpack_require__(4);

	var _CONST2 = _interopRequireDefault(_CONST);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TreeDiagram = function () {
	    function TreeDiagram() {
	        var _this = this;

	        var opt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        var container = arguments[1];

	        _classCallCheck(this, TreeDiagram);

	        this.opt = opt;
	        this.canvasInfo = _Canvas2.default.init(container, {
	            repaint: function repaint() {
	                // 画布拖动引发重绘
	                _this.draw();
	                console.info('redraw');
	            }
	        });
	        this.store = new _Store2.default(Object.assign({}, opt.data));
	        this.draw({
	            type: 'center',
	            node: this.store.root
	        });
	    }

	    _createClass(TreeDiagram, [{
	        key: 'setData',
	        value: function setData() {
	            var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	            var links = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

	            if (nodes.length === 0) {
	                this.canvasInfo.angel.clear();
	                return;
	            }
	            // 数据重置
	            this.store.setData(Object.assign([], nodes), Object.assign([], links));
	            this.draw({
	                type: 'center',
	                node: this.store.root
	            });
	        }
	    }, {
	        key: 'addData',
	        value: function addData() {
	            var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	            var links = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	            var centerNode = arguments[2];

	            // 数据追加,保留之前数据
	            this.store.updateData(Object.assign([], nodes), Object.assign([], links));
	            //this.animation(centerNode);
	            this.draw({
	                type: 'static',
	                node: centerNode
	            });
	        }
	    }, {
	        key: 'highLight',
	        value: function highLight(filter) {
	            var _this2 = this;

	            var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	            // 高亮节点
	            this.store.clearAllHighLight();
	            var currentIndex = 0,
	                currentNode = void 0;
	            // 过滤出需要高亮的节点
	            this.store.iteratorNode(function (node) {
	                delete node.hightLight;
	                if (filter(node)) {
	                    // 通过过滤, 高亮
	                    // 高亮节点分为当前焦点与其他符合条件的节点，分不同样式显示
	                    _this2.store.addHighLight(node, currentIndex === index ? 'this' : 'other');
	                    if (currentIndex === index) {
	                        currentNode = node;
	                    }
	                    currentIndex++;
	                }
	            });
	            if (currentIndex === 0) {
	                // 无节点
	                return 0;
	            }
	            this.draw();
	            if (!currentNode) {
	                // 找到对应节点，但index不在匹配数量之内
	                // 则符合条件节点加亮，但不移动定位
	                return currentIndex;
	            }
	            // 高亮节点居中
	            var canvasInfo = this.canvasInfo,

	            // 坐标运算
	            moveOpe = _Calcu2.default.calcuMoveDistance(currentNode, canvasInfo),

	            // 当前xy
	            nowX = canvasInfo.getTranslateX(),
	                nowY = canvasInfo.getTranslateY(),
	                canvas = canvasInfo.canvas;
	            // 此节点移动居中
	            $(canvas).animate({
	                a: 0
	            }, 0).animate({
	                a: 1
	            }, {
	                step: function step(n /* , fx */) {
	                    var newX = nowX + (moveOpe.moveX - nowX) * n,
	                        newY = nowY + (moveOpe.moveY - nowY) * n;
	                    canvasInfo.setTranslate(newX, newY);
	                },
	                duration: 500
	            });

	            if (moveOpe.redraw) {
	                this.draw();
	                console.info('redraw');
	            }
	            // 返回高亮节点数
	            return currentIndex;
	        }
	    }, {
	        key: 'clearAllHighLight',
	        value: function clearAllHighLight() {
	            this.store.clearAllHighLight();
	            this.draw();
	        }
	        // animation(staticNode){
	        //     // 动画方法, 未优化，全部重绘
	        //     if(!this.store.root){
	        //         return;
	        //     }
	        //     let originPosition = {},
	        //         parentNode;
	        //     this.store.iteratorNode((node) => {
	        //         if(node.type !== 'root'){
	        //             parentNode = node.type === 'parent' ? node.children[0] : node.parents[0];
	        //         }
	        //         originPosition[node.id] = {
	        //             x: node.x === undefined ? parentNode.x : node.x,
	        //             y: node.y === undefined ? parentNode.y : node.y
	        //         };
	        //     });
	        //     let angel = this.canvasInfo.angel,
	        //         cx = this.canvasInfo.centerX,
	        //         cy = this.canvasInfo.centerY,
	        //         data = staticNode ?
	        //             Calcu.layoutNodeByStatic(this.store.getExpendData(), staticNode) :
	        //             Calcu.layoutNodeByCenter(this.store.getExpendData(), this.store.root),
	        //         nodes = data.nodes,
	        //         links = data.links,
	        //         animationSpend = 200,
	        //         now = new Date().getTime(),
	        //         numberCalcu = (start, end, time) => {
	        //             return start + (end - start) * (Math.min(time - now, animationSpend)) / animationSpend;
	        //         },
	        //         draw = () => {
	        //             let time = new Date().getTime();
	        //             // 清空
	        //             angel.clear();
	        //
	        //             nodes.forEach((node) => {
	        //                 // 绘制点
	        //                 let nodeX = numberCalcu(originPosition[node.id].x, node.x, time) + cx,//node.x + cx
	        //                     nodeY = numberCalcu(originPosition[node.id].y, node.y, time) + cy;//node.y + cy
	        //                 let circle = new Angel.Circle({
	        //                     zlevel: 2,
	        //                     style : {
	        //                         cursor: node.type === 'root' ? 'default' : 'pointer',
	        //                         x: nodeX,
	        //                         y: nodeY,
	        //                         r: node.size/2,
	        //                         brushType : 'both',
	        //                         fillStyle : node.color,
	        //                         strokeStyle: node.borderColor,
	        //                         lineWidth : node.borderWidth
	        //                     },
	        //                     data: node
	        //                 });
	        //                 angel.addShape(circle);
	        //                 // 绑定点击事件
	        //                 this.bindEvent(circle);
	        //                 // 绘制文字
	        //                 let textInfo = Calcu.calcuText(node.name, CONST.fontSize, CONST.fontMaxLength),
	        //                     textX = node.type === 'parent' ?
	        //                         nodeX - node.size/2 - CONST.fontMargin - textInfo.length:
	        //                         nodeX + node.size/2 + CONST.fontMargin;
	        //                 let textShape = new Angel.Text({
	        //                     zlevel: 2,
	        //                     style: {
	        //                         brushType: 'fill',
	        //                         fillStyle: CONST.fontColor,
	        //                         font: CONST.fontSize + 'px ' + CONST.fontFamily,
	        //                         x: textX,
	        //                         y: nodeY + (CONST.fontSize/4),
	        //                         text: node.type === 'root' ? '' : textInfo.text
	        //                     }
	        //                 });
	        //                 angel.addShape(textShape);
	        //             });
	        //             // 绘制线
	        //             links.forEach((link) => {
	        //                 let line = new Angel.BezierCurve({
	        //                     zlevel: 1,
	        //                     style: {
	        //                         brushType : 'stroke',
	        //                         lineWidth : link.data.size,
	        //                         strokeStyle: link.data.color,
	        //                         points: Calcu.layoutLine(
	        //                         {
	        //                             x: numberCalcu(originPosition[link.from.id].x, link.from.x, time),//node.x + cx,
	        //                             y: numberCalcu(originPosition[link.from.id].y, link.from.y, time),//node.y + cy,
	        //                         },
	        //                         {
	        //                             x: numberCalcu(originPosition[link.to.id].x, link.to.x, time),//node.x + cx,
	        //                             y: numberCalcu(originPosition[link.to.id].y, link.to.y, time),//node.y + cy,
	        //                         },
	        //                         {
	        //                             x: cx,
	        //                             y: cy
	        //                         }
	        //                         )
	        //                     }
	        //                 });
	        //                 angel.addShape(line);
	        //             });
	        //             angel.render();
	        //             return (time - now) >= animationSpend;
	        //         };
	        //     let isEnd = false;;
	        //     function step() {
	        //         if(!isEnd){
	        //             isEnd = draw();
	        //             requestAnimationFrame(step);
	        //         }
	        //     }
	        //     requestAnimationFrame(step);
	        //     draw();
	        // }

	    }, {
	        key: 'draw',
	        value: function draw(config) {
	            var _this3 = this;

	            // 无根节点,不绘制
	            if (!this.store.root) {
	                return;
	            }
	            var angel = this.canvasInfo.angel,
	                cx = this.canvasInfo.centerX,
	                cy = this.canvasInfo.centerY,
	                data = _Calcu2.default.layoutNode(this.store, config),
	                nodes = data.nodes,
	                links = data.links;
	            // 清空
	            angel.clear();

	            // 绘制点
	            nodes.forEach(function (node) {
	                var circle = new Angel.Circle({
	                    zlevel: 3,
	                    style: {
	                        cursor: node.type === 'root' ? 'default' : 'pointer',
	                        x: node.x + cx,
	                        y: node.y + cy,
	                        r: node.size / 2,
	                        brushType: 'both',
	                        fillStyle: node.color,
	                        strokeStyle: node.borderColor,
	                        lineWidth: node.borderWidth
	                    },
	                    data: node
	                });
	                angel.addShape(circle);
	                // 绑定点击事件
	                _this3.bindEvent(circle);
	                // 绘制文字
	                var textInfo = _Calcu2.default.calcuText(node.name, _CONST2.default.fontSize, _CONST2.default.fontFamily),
	                    textX = node.type === 'parent' ? node.x + cx - node.size / 2 - _CONST2.default.fontMargin - textInfo.width : node.x + cx + node.size / 2 + _CONST2.default.fontMargin;

	                // if(node.highLight){
	                //     // 高亮字背景
	                //     let shape = new Angel.Rect({
	                //         zlevel: 2,
	                //         style: {
	                //             brushType: 'fill',
	                //             fillStyle: '#f00',
	                //             x: textX,
	                //             y: node.y + cy,
	                //             w: textInfo.width,
	                //             h: CONST.fontSize,//textInfo.height,
	                //             text: node.type === 'root' ? '' : textInfo.text
	                //         }
	                //     });
	                //     angel.addShape(shape);
	                //     console.info(textInfo);
	                // }
	                var textShape = new Angel.Text({
	                    zlevel: 3,
	                    style: {
	                        brushType: 'fill',
	                        fillStyle: _CONST2.default.fontColor,
	                        font: _CONST2.default.fontSize + 'px ' + _CONST2.default.fontFamily,
	                        x: textX,
	                        y: node.y + cy + _CONST2.default.fontSize / 4,
	                        text: node.type === 'root' ? '' : textInfo.text
	                    }
	                });
	                angel.addShape(textShape);
	            });
	            // 绘制线
	            links.forEach(function (link) {
	                var line = new Angel.BezierCurve({
	                    zlevel: 1,
	                    style: {
	                        brushType: 'stroke',
	                        lineWidth: link.size,
	                        strokeStyle: link.color,
	                        points: _Calcu2.default.layoutLine(link.from, link.to, {
	                            x: cx,
	                            y: cy
	                        })
	                    }
	                });
	                angel.addShape(line);
	            });
	            angel.render();
	        }
	    }, {
	        key: '_drawPathHighLight',
	        value: function _drawPathHighLight(links) {
	            // 绘制高亮线段
	            var angel = this.canvasInfo.angel,
	                cx = this.canvasInfo.centerX,
	                cy = this.canvasInfo.centerY;

	            // 绘制线
	            links.forEach(function (link) {
	                var line = new Angel.BezierCurve({
	                    zlevel: 2,
	                    style: {
	                        brushType: 'stroke',
	                        lineWidth: link.size,
	                        strokeStyle: link.color,
	                        points: _Calcu2.default.layoutLine(link.fromNode, link.toNode, {
	                            x: cx,
	                            y: cy
	                        })
	                    }
	                });
	                angel.addShape(line);
	            });
	            angel.render();
	        }
	    }, {
	        key: '_clearPathHighLight',
	        value: function _clearPathHighLight() {
	            // 清除路径高亮
	            this.canvasInfo.angel.clear(2);
	        }
	    }, {
	        key: 'bindEvent',
	        value: function bindEvent(nodeShape) {
	            // click事件
	            this.bindClickEvent(nodeShape);
	            // 右键事件
	            this.bindContextMenuEvent(nodeShape);
	            // hover事件
	            this.bindHoverEvent(nodeShape);
	        }
	    }, {
	        key: 'bindClickEvent',
	        value: function bindClickEvent(nodeShape) {
	            var _this4 = this;

	            // 节点点击事件
	            var originData = nodeShape.data.originData;
	            nodeShape.on('click', function () {
	                if (originData.type === 'root') {
	                    // 根节点无点击事件
	                    return;
	                }
	                var nodeData = _this4.store.getNodeById(originData.id);
	                nodeData.isExpend = !nodeData.isExpend;
	                // 展开
	                if (nodeData.isExpend) {
	                    var childNodes = nodeData.type === 'parent' ? nodeData._parents : nodeData._children;
	                    if (!childNodes) {
	                        // 第一次展开操作
	                        if (_this4.opt.onExpand) {
	                            _this4.opt.onExpand.call(_this4, originData, function () {
	                                var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	                                var links = arguments[1];

	                                nodes.forEach(function (node) {
	                                    node.type = nodeData.type;
	                                });
	                                _this4.addData(nodes, links, nodeShape.data);
	                            });
	                        }
	                    } else if (childNodes.length > 0) {
	                        // 展开、重绘
	                        _this4.draw({
	                            type: 'static',
	                            node: nodeShape.data
	                        });
	                    }
	                }
	                // 收起
	                else {
	                        _this4.draw({
	                            type: 'static',
	                            node: nodeShape.data
	                        });
	                    }
	            });
	        }
	    }, {
	        key: 'bindHoverEvent',
	        value: function bindHoverEvent(nodeShape) {
	            var _this5 = this;

	            // hover事件
	            var originData = nodeShape.data.originData,
	                mouseHandle = function mouseHandle(e, callback) {
	                if (callback) {
	                    callback.call(_this5, e, originData);
	                }
	            };
	            nodeShape.on('mouseover', function (e) {
	                _this5._clearPathHighLight();
	                // 获取高亮线段
	                var lightLines = _this5.store.getHighLightPath(originData.id);
	                _this5._drawPathHighLight(lightLines);
	                mouseHandle(e, _this5.opt.onNodeMouseEnter);
	            });
	            nodeShape.on('mouseout', function (e) {
	                // 清除高亮路径
	                _this5._clearPathHighLight();
	                mouseHandle(e, _this5.opt.onNodeMouseLeave);
	            });
	        }
	    }, {
	        key: 'bindContextMenuEvent',
	        value: function bindContextMenuEvent(nodeShape) {
	            var _this6 = this;

	            // 右键事件
	            nodeShape.on('contextmenu', function (e) {
	                if (_this6.opt.onContextMenu) {
	                    _this6.opt.onContextMenu.call(_this6, e, nodeShape.data.originData);
	                }
	            });
	        }
	    }]);

	    return TreeDiagram;
	}();

	window.TreeDiagram = TreeDiagram;
	exports.default = TreeDiagram;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global d3, dagre  */


	var _CONST = __webpack_require__(4);

	var _CONST2 = _interopRequireDefault(_CONST);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Calcu = function () {
	    function Calcu() {
	        _classCallCheck(this, Calcu);
	    }

	    _createClass(Calcu, [{
	        key: 'layoutNode',
	        value: function layoutNode(store, config) {
	            // 布局计算
	            if (!config) {
	                return this._layoutResult;
	            } else if (config.type === 'static') {
	                return this.layoutNodeByStaticUserD3(store, config.node);
	            } else if (config.type === 'center') {
	                return this.layoutNodeByCenter(store, config.node);
	            }
	        }
	    }, {
	        key: 'layoutNodeByCenter',
	        value: function layoutNodeByCenter(store, centerNode) {
	            // 以centerNode为中心点布局
	            centerNode.originX = centerNode.originY = 0;
	            return this.layoutNodeByStaticUserD3(store, centerNode);
	        }
	    }, {
	        key: 'layoutNodeByStaticUserD3',
	        value: function layoutNodeByStaticUserD3(store, staticNode) {
	            // d3布局
	            var result = {
	                nodes: [],
	                links: []
	            },
	                adX = 0,
	                adY = 0,
	                layout = function layout(direction, isExceptRoot) {
	                var root = store.root,
	                    linkMap = store.linkMap;
	                // 遍历节点，为展开标志的节点添加children属性
	                // children: d3算法需要，意为子节点
	                store.iteratorNode(function (node) {
	                    // 展开节点才设置children，参与布局
	                    if (node.isExpend) {
	                        node.children = direction === 'right' ? node._children : node._parents;
	                    } else {
	                        delete node.children;
	                    }
	                }, direction === 'right' ? 'children' : 'parents');

	                // d3 布局算法
	                var tree = d3.layout.tree().nodeSize([_CONST2.default.nodeSize, _CONST2.default.nodeSize]).separation(function (a, b) {
	                    var dis = _CONST2.default.nodesep / _CONST2.default.nodeSize;
	                    return a.parent == b.parent ? dis : 2 * dis;
	                }),
	                    nodes = tree.nodes(root).reverse();

	                nodes.forEach(function (node) {
	                    node.y = node.depth * _CONST2.default.ranksep;
	                    // 其他节点针对固定节点的偏移值
	                    if (staticNode && staticNode.id === node.id) {
	                        // staticNode为固定节点，即本次重绘不会改变其坐标
	                        var sNode = Object.assign({ originX: staticNode.x, originY: staticNode.Y }, staticNode),
	                            n = direction === 'right' ? 1 : -1;
	                        if (sNode.originX || sNode.originY) {
	                            adX = sNode.originX - n * sNode.y;
	                            adY = sNode.originY + n * sNode.x;
	                        }
	                    }
	                });

	                nodes.forEach(function (node) {
	                    // node.originX = node.x = node.x + adX;
	                    // node.originY = node.y = node.y + adY;
	                    if (!isExceptRoot || node.type !== 'root') {
	                        node.originX = node.x;
	                        node.originY = node.y;
	                        var x = node.x,
	                            y = node.y,
	                            n = direction === 'right' ? 1 : -1;
	                        node.x = n * y;
	                        node.y = -n * x;
	                        result.nodes.push(node);
	                    }
	                    if (node.children) {
	                        node.children.forEach(function (n) {
	                            result.links.push(Object.assign({}, linkMap[node.id + '_' + n.id] || linkMap[n.id + '_' + node.id], {
	                                from: node,
	                                to: n
	                            }));
	                        });
	                    }
	                });
	            };

	            // d3树算法只支持树形布局，所以这里把图形拆成里两棵树分别布局
	            layout('right');
	            layout('left', true);
	            result.nodes.forEach(function (node) {
	                node.originX = node.x = node.x + adX;
	                node.originY = node.y = node.y + adY;
	            });
	            this._layoutResult = result;
	            return result;
	        }
	    }, {
	        key: 'layoutLine',
	        value: function layoutLine(from, to, adjust) {
	            // 贝塞尔曲线
	            var x1 = from.x,
	                y1 = from.y,
	                x2 = to.x,
	                y2 = to.y;
	            return [x1 + adjust.x, y1 + adjust.y, (x1 + x2) / 2 + adjust.x, y1 + adjust.y, (x1 + x2) / 2 + adjust.x, y2 + adjust.y, x2 + adjust.x, y2 + adjust.y];
	        }
	    }, {
	        key: 'calcuText',
	        value: function calcuText(text, fontSize, fontFamily /* , maxLength */) {
	            // 计算文字长度(px)，超过最大长度(maxLength)的用...结尾表示
	            text = text || '';
	            text = text.toString();
	            var tempCanvas = document.createElement('canvas'),
	                ctx = tempCanvas.getContext("2d");
	            ctx.font = fontSize + 'px ' + fontFamily;
	            return {
	                text: text,
	                width: Math.ceil(ctx.measureText(text).width),
	                height: Math.ceil(ctx.measureText(text).height)
	            };
	        }
	    }, {
	        key: 'calcuMoveDistance',
	        value: function calcuMoveDistance(node, canvas) {
	            // 计算将node移动到屏幕中心所对应的画布的translate值
	            var isInBound = function isInBound(screenNum) {
	                if (Math.abs(node.x + canvas.centerX - canvas.width / 2) > screenNum * canvas.screenWidth || Math.abs(node.y + canvas.centerY - canvas.height / 2) > screenNum * canvas.screenHeight) {
	                    return false;
	                }
	                return true;
	            },
	                moveX = 0,
	                moveY = 0,
	                redraw = false;

	            if (isInBound(2)) {
	                var _canvas$getMoveXY = canvas.getMoveXY();

	                var x = _canvas$getMoveXY.x;
	                var y = _canvas$getMoveXY.y;
	                var translateX = canvas.getTranslateX();
	                var translateY = canvas.getTranslateY();
	                moveX = translateX - node.x - canvas.centerX + canvas.width / 2 - x;
	                moveY = translateY - node.y - canvas.centerY + canvas.height / 2 - y;
	                // 焦点在缓存区之内(离缓存区中心2屏幕之内)
	                if (isInBound(1)) {
	                    // 焦点距离缓存中心1屏幕之内，无需重绘，直接移动
	                    redraw = false;
	                } else {
	                    // 焦点距离缓存中心1-2.0屏幕,
	                    // 先移动，再重绘(以防下次拖动画布超出缓存区显示空白)
	                    redraw = true;
	                }
	            } else {
	                // 焦点在缓存区之外
	            }
	            return {
	                moveX: moveX,
	                moveY: moveY,
	                redraw: redraw
	            };
	        }
	    }]);

	    return Calcu;
	}();

	exports.default = new Calcu();

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/* global Angel  */

	var Canvas = function () {
	    function Canvas() {
	        _classCallCheck(this, Canvas);
	    }

	    _createClass(Canvas, [{
	        key: 'init',

	        // 画布类，控制离屏缓存以及重绘
	        value: function init(container) {
	            var opt = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	            var canvas = this.createCanvas(container);
	            this.angel = Angel.init(canvas);
	            this.repaint = opt.repaint;

	            this.bindEvent(canvas);
	            return this;
	        }
	    }, {
	        key: 'getTranslateX',
	        value: function getTranslateX() {
	            var dom = arguments.length <= 0 || arguments[0] === undefined ? this.canvas : arguments[0];

	            return this.getTranslate(dom, 0);
	        }
	    }, {
	        key: 'getTranslateY',
	        value: function getTranslateY() {
	            var dom = arguments.length <= 0 || arguments[0] === undefined ? this.canvas : arguments[0];

	            return this.getTranslate(dom, 1);
	        }
	    }, {
	        key: 'getTranslate',
	        value: function getTranslate(dom, i) {
	            var str = dom.style.transform;
	            return parseInt(str.match(/(\-)?[\.\d]+/g)[i]);
	        }
	    }, {
	        key: 'getMoveXY',
	        value: function getMoveXY() {
	            // 获取画布相对移动距离
	            var x = this.getTranslateX(),
	                y = this.getTranslateY(),
	                w = this.canvas.offsetWidth,
	                h = this.canvas.offsetHeight;
	            return {
	                x: x + w * 0.4,
	                y: y + h * 0.4
	            };
	        }
	    }, {
	        key: 'setTranslate',
	        value: function setTranslate(x, y) {
	            this.canvas.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
	        }
	    }, {
	        key: 'createCanvas',
	        value: function createCanvas(container) {
	            var canvas = this.canvas = document.createElement('div'),
	                canvasContainer = document.createElement('div');
	            container.appendChild(canvasContainer);
	            canvasContainer.appendChild(canvas);
	            canvasContainer.style.overflow = "hidden";
	            canvas.style.position = "relative";
	            canvas.style.width = 5 * container.offsetWidth + 'px';
	            canvas.style.height = 5 * container.offsetHeight + 'px';
	            this.setTranslate(-0.4 * canvas.offsetWidth, -0.4 * canvas.offsetHeight);
	            this.screenWidth = container.offsetWidth;
	            this.screenHeight = container.offsetHeight;
	            this.width = 5 * container.offsetWidth;
	            this.height = 5 * container.offsetHeight;
	            this.centerX = 2.5 * container.offsetWidth;
	            this.centerY = 2.5 * container.offsetHeight;
	            return canvas;
	        }
	    }, {
	        key: 'initCanvasPosition',
	        value: function initCanvasPosition() {
	            var canvas = this.canvas;
	            this.setTranslate(-0.4 * canvas.offsetWidth, -0.4 * canvas.offsetHeight);
	        }
	    }, {
	        key: 'bindEvent',
	        value: function bindEvent(canvasDom) {
	            var _this = this;

	            // 绑定画布拖动状态
	            var dom = canvasDom,
	                isDown = false,
	                startX = void 0,
	                startY = void 0,
	                domX = void 0,
	                domY = void 0;

	            var dragComplete = function dragComplete() {
	                isDown = false;
	                var w = _this.width,
	                    h = _this.height,
	                    x = _this.getTranslateX(dom),
	                    y = _this.getTranslateY(dom);
	                if (x < -0.6 * w || x > -0.2 * w || y < -0.6 * h || y > -0.2 * y) {
	                    if (_this.repaint) {
	                        _this.centerX += x + _this.width * 0.4;
	                        _this.centerY += y + _this.height * 0.4;
	                        _this.initCanvasPosition();
	                        _this.repaint();
	                    }
	                }
	            };
	            $(document).on('mousedown', dom, function (e) {
	                isDown = true;
	                startX = e.pageX;
	                startY = e.pageY;
	                domX = _this.getTranslateX(dom);
	                domY = _this.getTranslateY(dom);
	            }).on('mousemove', dom, function (e) {
	                if (isDown) {
	                    // 画布拖动
	                    _this.setTranslate(domX + e.pageX - startX, domY + e.pageY - startY);
	                }
	            }).on('mouseup', dom, dragComplete);
	        }
	    }]);

	    return Canvas;
	}();

	exports.default = new Canvas();

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global  */


	var _CONST = __webpack_require__(4);

	var _CONST2 = _interopRequireDefault(_CONST);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Store = function () {
	    function Store(data) {
	        _classCallCheck(this, Store);

	        this.defaultNodeStyleOpt = {
	            'root': {
	                // 根节点配置
	                color: _CONST2.default.rootNodeColor,
	                borderColor: _CONST2.default.rootNodeBorderColor,
	                size: _CONST2.default.rootSize
	            },
	            'parent': {
	                // 左侧节点配置
	                color: _CONST2.default.parentNodeColor,
	                borderColor: _CONST2.default.parentNodeBorderColor,
	                size: _CONST2.default.nodeSize
	            },
	            'child': {
	                // 右侧节点配置
	                color: _CONST2.default.childNodeColor,
	                borderColor: _CONST2.default.childNodeBorderColor,
	                size: _CONST2.default.nodeSize
	            }
	        };
	        if (data) {
	            this.setData(data.nodes, data.links);
	        }
	    }

	    _createClass(Store, [{
	        key: 'setData',
	        value: function setData(nodes, links) {
	            //数据设置，会清除之前数据
	            this.nodeMap = {};
	            this.linkMap = {};
	            this._dataFormat(nodes, links);
	        }
	    }, {
	        key: 'updateData',
	        value: function updateData(nodes, links) {
	            // 数据更新
	            this._dataFormat(nodes, links);
	        }
	    }, {
	        key: 'getNodeById',
	        value: function getNodeById(id) {
	            this.nodeMap = this.nodeMap || {};
	            return this.nodeMap[id];
	        }
	    }, {
	        key: 'addHighLight',
	        value: function addHighLight(node, type) {
	            // 增加高亮节点
	            node.highLight = type;
	            if (type === 'this') {}
	            //node.borderColor = CONST.highLightCurrentColor;

	            // else{
	            //     node.borderColor = CONST.highLightColor;
	            // }
	        }
	    }, {
	        key: 'clearAllHighLight',
	        value: function clearAllHighLight() {
	            // 清除所有节点高亮效果
	            this.iteratorNode(function (node) {
	                delete node.hightLight;
	                // node.borderColor = this.defaultNodeStyleOpt[node.type].borderColor;
	            });
	        }
	    }, {
	        key: 'iteratorNode',
	        value: function iteratorNode(callback, iteratorDerect) {
	            if (!this.root) {
	                return;
	            }
	            var iterator = function iterator(node, direct, index) {
	                if (node.type !== 'root') {
	                    callback(node, index);
	                }
	                if (node.isExpend && node[direct]) {
	                    // 递归子结点
	                    node[direct].forEach(function (son, i) {
	                        iterator(son, direct, i);
	                    });
	                }
	            };
	            callback(this.root);
	            if (!iteratorDerect || iteratorDerect === 'parents') {
	                iterator(this.root, '_parents');
	            }
	            if (!iteratorDerect || iteratorDerect === 'children') {
	                iterator(this.root, '_children');
	            }
	        }
	    }, {
	        key: 'getExpendData',
	        value: function getExpendData() {
	            // 获取已展开节点的信息(未展开节点不需要显示)
	            var nodes = [],
	                links = [],
	                root = this.root,
	                linkMap = this.linkMap,
	                iterator = function iterator(node, direct, isExceptRoot) {
	                if (!isExceptRoot) {
	                    nodes.push(node);
	                }
	                if (node.isExpend && node[direct]) {
	                    // 递归子结点
	                    node[direct].forEach(function (son) {
	                        links.push(linkMap[node.id + '_' + son.id] || linkMap[son.id + '_' + node.id]);
	                        iterator(son, direct);
	                    });
	                }
	            };
	            if (root) {
	                iterator(root, '_parents');
	                iterator(root, '_children', true);
	            }
	            return {
	                nodes: nodes,
	                links: links
	            };
	        }
	    }, {
	        key: '_dataFormat',
	        value: function _dataFormat(nodes, links) {
	            var _this = this;

	            // 数据上下级关系绑定
	            nodes = nodes || [], links = links || [];

	            // 保存节点信息
	            this.nodeMap = this.nodeMap || {};
	            nodes.forEach(function (node) {
	                if (!_this.nodeMap[node.id]) {
	                    // 添加默认属性，如颜色、边框厚度等
	                    _this.nodeMap[node.id] = Object.assign({
	                        originData: node
	                    }, node);
	                    if (node.type === 'root') {
	                        _this.root = _this.nodeMap[node.id];
	                    }
	                }
	            });
	            // 解析连线，绑定节点上下级关系
	            this.linkMap = this.linkMap || {};
	            links.forEach(function (link) {
	                var from = _this.nodeMap[link.from],
	                    to = _this.nodeMap[link.to],
	                    key = link.from + '_' + link.to;

	                if (!_this.linkMap[key]) {
	                    from._children = from._children || [];
	                    from._children.push(to);
	                    to._parents = to._parents || [];
	                    to._parents.push(from);
	                    _this.linkMap[key] = Object.assign({
	                        fromNode: from,
	                        toNode: to
	                    }, link);
	                    if (from.type === 'parent') {
	                        to.isExpend = true;
	                    } else {
	                        from.isExpend = true;
	                    }
	                }
	            });
	            // 节点样式设置
	            this._nodeStyleMixin();
	            // 线样式设置
	            this._linkStyleMixin();
	        }
	    }, {
	        key: '_nodeStyleMixin',
	        value: function _nodeStyleMixin() {
	            var _this2 = this;

	            // 节点样式设置(填充色，边框颜色)
	            var getParentNode = function getParentNode(node) {
	                if (node.type === 'parent') {
	                    return node._children[0];
	                } else if (node.type === 'child') {
	                    return node._parents[0];
	                }
	            },
	                defaultNodeOpt = this.defaultNodeStyleOpt,
	                colors = _CONST2.default.topLevelColors,
	                borderColors = _CONST2.default.topLevelBorderColors,
	                colorOpt = void 0;
	            this.iteratorNode(function (node, i) {
	                colorOpt = {};
	                if (node.type !== 'root') {
	                    var parentNode = getParentNode(node);
	                    if (parentNode.type !== 'root') {
	                        // 节点颜色与父节点相同
	                        colorOpt = {
	                            color: parentNode.color,
	                            borderColor: parentNode.borderColor
	                        };
	                    } else {
	                        // 若父节点为root，则从配置里拿初始颜色
	                        colorOpt = {
	                            color: colors[i % colors.length],
	                            borderColor: borderColors[i % borderColors.length]
	                        };
	                    }
	                }
	                var newAttr = Object.assign({
	                    borderWidth: _CONST2.default.borderWidth
	                }, defaultNodeOpt[node.type], colorOpt, node);
	                Object.assign(_this2.nodeMap[node.id], newAttr);
	            });
	        }
	    }, {
	        key: '_linkStyleMixin',
	        value: function _linkStyleMixin() {
	            // 线条样式设置
	            var style = void 0;
	            for (var i in this.linkMap) {
	                // 属性设置 线个性化设置优先，否则取关联的非root节点颜色
	                var link = this.linkMap[i],
	                    node = link.toNode.type === 'root' ? link.fromNode : link.toNode;
	                style = {
	                    color: link.color || node.borderColor.replace(/[\d\.]+[ ]*\)/, '0.2)'),
	                    size: link.size || _CONST2.default.linkSize
	                };
	                Object.assign(link, style);
	            }
	        }
	    }, {
	        key: 'getHighLightPath',
	        value: function getHighLightPath(id) {
	            var node = this.nodeMap[id],
	                linkMap = this.linkMap,
	                lightLines = [],
	                direction = node.type === 'parent' ? '_children' : '_parents';
	            if (node.type === 'root') {
	                return [];
	            }

	            var parentNode = void 0,
	                linkOpt = void 0;
	            while (node[direction] && node[direction].length > 0) {
	                // 向父节点追溯
	                parentNode = node[direction][0];
	                linkOpt = linkMap[node.id + '_' + parentNode.id] || linkMap[parentNode.id + '_' + node.id];
	                // 沿途线加亮
	                lightLines.push(Object.assign({}, linkOpt, { color: linkOpt.color.replace(/[\d\.]+[ ]*\)/, '1)') }));
	                node = parentNode;
	                if (node.type === 'root') {
	                    break;
	                }
	            }
	            return lightLines;
	        }
	    }]);

	    return Store;
	}();

	exports.default = Store;

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/* global  */
	exports.default = {
	    ranksep: 135, // 节点层级间的距离
	    nodesep: 42, // 同级节点间距离
	    rankdir: 'LR', // 图布局方向
	    borderWidth: 1, // 节点边框厚度
	    childNodeBorderColor: 'rgba(253, 189, 97, 1)', // 右侧节点边框颜色
	    childNodeColor: 'rgba(254, 220, 171, 1)', // 右侧节点填充色
	    childLinkColor: 'rgba(255, 242, 224, 1)', // 右侧线颜色
	    parentNodeBorderColor: 'rgba(160, 218, 131, 1)', // 左侧节点边框颜色
	    parentNodeColor: 'rgba(187, 229, 165, 1)', // 左侧节点填充色
	    parentLinkColor: 'rgba(236, 248, 230, 1)', // 左侧线颜色
	    rootNodeBorderColor: 'rgba(93, 198, 236, 1)', // 根节点边框颜色
	    rootNodeColor: 'rgba(164, 231, 254, 1)', // 根节点填充色
	    // highLightCurrentColor: 'rgba(237, 95, 97, 1)', // 高亮节点颜色(当前聚焦点)
	    // highLightColor: 'rgba(255, 150, 50, 1)', // 高亮节点颜色
	    topLevelColors: ['rgba(203, 101, 102, 1)', 'rgba(246, 130, 131, 1)', 'rgba(235, 107, 42,  1)', 'rgba(231, 145, 68,  1)', 'rgba(236, 182, 55,  1)', 'rgba(243, 209, 66,  1)', 'rgba(207, 232, 98,  1)', 'rgba(182, 214, 92,  1)', 'rgba(156, 209, 121, 1)', 'rgba(118, 182, 85,  1)'], // 第一层树节点颜色序列
	    topLevelBorderColors: ['rgba(171, 82, 2, 1)', 'rgba(186, 93, 13, 1)', 'rgba(202, 78, 1, 1)', 'rgba(195, 89, 4, 1)', 'rgba(198, 153, 14, 1)', 'rgba(202, 174, 8, 1)', 'rgba(162, 191, 13, 1)', 'rgba(130, 155, 11, 1)', 'rgba(118, 169, 3, 1)', 'rgba(89, 142, 12, 1)'], // 第一层树节点边框颜色
	    fontColor: '#666', // 字体颜色
	    fontSize: 12,
	    fontFamily: 'Verdana',
	    fontMargin: 5, // 字体与节点距离
	    fontMaxLength: 20, // 字体最长字符数,超出用...表示
	    nodeSize: 20, // 普通节点直径
	    linkSize: 4, // 线宽度
	    rootSize: 32 // 根节点直径
	};

/***/ }
/******/ ]);